# SortingAlgorithms
I are covering a selection of classic sorting algorithms, including:

Insertion Sort
Bucket Sort
Quick Sort
Merge Sort
Contained within this repository is a Jupyter Notebook which provides clear and concise code implementations of these algorithms, with accompanying explanations.

Contents

Insertion Sort
An easy-to-understand, stable sorting algorithm that's great for small datasets and mostly sorted data. However, it performs poorly on large, reverse-sorted arrays. Worse Time complexity: O(n²)
Best Tiem complexity: O(n)

Bucket Sort
This algorithm works by distributing the array elements into several "buckets", sorting these individually, and then merging them. Ideal for uniformly distributed data. Time complexity: O(n + k)

Quick Sort
Quick Sort is a highly efficient sorting algorithm that employs the divide-and-conquer strategy. Its worst-case time complexity is O(n²), and at O(n log n) in the average case.

Merge Sort
Merge Sort is a stable, divide-and-conquer, sorting algorithm. It's consistent, with a time complexity of O(n log n), making it best for large datasets that don't fit into memory.

