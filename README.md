# SortingAlgorithms
I are covering a selection of classic sorting algorithms, including:

Insertion Sort,
Quick Sort,
Merge Sort,
and Bucket Sort

Contained within this repository is a Jupyter Notebook which provides clear and concise code implementations of these algorithms.

Contents

Insertion Sort
An easy-to-understand, stable sorting algorithm that's great for small datasets and mostly sorted data. However, it performs poorly on large, reverse-sorted arrays. Worse Time complexity: O(n²)
Best Tiem complexity: O(n)

Quick Sort
Quick Sort is a highly efficient sorting algorithm that employs the divide-and-conquer strategy. 
Its worst-case time complexity is O(n²) if pivot not choosing carefully, and at O(n log n) in the average case.

Merge Sort
Merge Sort is a stable, divide-and-conquer, sorting algorithm. It's consistent, with a time complexity of O(n log n), making it best for large datasets that don't fit into memory.

Bucket Sort
This algorithm works by creating an array of several "buckets" containing the frequencies of the elements in the actual array to sort. Its works with arrays with uniform distributions. In the case of my code, the array is in [0,3]. 
Time complexity: O(n)
